// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: cometbft/services/node/v1/node.proto

package v1

import (
	fmt "fmt"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	_ "github.com/cosmos/gogoproto/types"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// GetStatusRequest is an empty message sent in a call to GetStatus.
// The GetStatus rpc call requires no parameter.
type GetStatusRequest struct {
}

func (m *GetStatusRequest) Reset()         { *m = GetStatusRequest{} }
func (m *GetStatusRequest) String() string { return proto.CompactTextString(m) }
func (*GetStatusRequest) ProtoMessage()    {}
func (*GetStatusRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c29a81d3e8b4adc4, []int{0}
}
func (m *GetStatusRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetStatusRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetStatusRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetStatusRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetStatusRequest.Merge(m, src)
}
func (m *GetStatusRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetStatusRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetStatusRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetStatusRequest proto.InternalMessageInfo

// NodeInfo contains basic information about the node.
type NodeInfo struct {
	ProtocolVersion *NodeInfo_ProtocolVersion `protobuf:"bytes,1,opt,name=protocol_version,json=protocolVersion,proto3" json:"protocol_version,omitempty"`
	Id              string                    `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	ListenAddr      string                    `protobuf:"bytes,3,opt,name=listen_addr,json=listenAddr,proto3" json:"listen_addr,omitempty"`
	Network         string                    `protobuf:"bytes,4,opt,name=network,proto3" json:"network,omitempty"`
	Version         string                    `protobuf:"bytes,5,opt,name=version,proto3" json:"version,omitempty"`
	Channels        []byte                    `protobuf:"bytes,6,opt,name=channels,proto3" json:"channels,omitempty"`
	Moniker         string                    `protobuf:"bytes,7,opt,name=moniker,proto3" json:"moniker,omitempty"`
	Other           *NodeInfo_NodeInfoOther   `protobuf:"bytes,8,opt,name=other,proto3" json:"other,omitempty"`
}

func (m *NodeInfo) Reset()         { *m = NodeInfo{} }
func (m *NodeInfo) String() string { return proto.CompactTextString(m) }
func (*NodeInfo) ProtoMessage()    {}
func (*NodeInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_c29a81d3e8b4adc4, []int{1}
}
func (m *NodeInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeInfo.Merge(m, src)
}
func (m *NodeInfo) XXX_Size() int {
	return m.Size()
}
func (m *NodeInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeInfo.DiscardUnknown(m)
}

var xxx_messageInfo_NodeInfo proto.InternalMessageInfo

func (m *NodeInfo) GetProtocolVersion() *NodeInfo_ProtocolVersion {
	if m != nil {
		return m.ProtocolVersion
	}
	return nil
}

func (m *NodeInfo) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *NodeInfo) GetListenAddr() string {
	if m != nil {
		return m.ListenAddr
	}
	return ""
}

func (m *NodeInfo) GetNetwork() string {
	if m != nil {
		return m.Network
	}
	return ""
}

func (m *NodeInfo) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *NodeInfo) GetChannels() []byte {
	if m != nil {
		return m.Channels
	}
	return nil
}

func (m *NodeInfo) GetMoniker() string {
	if m != nil {
		return m.Moniker
	}
	return ""
}

func (m *NodeInfo) GetOther() *NodeInfo_NodeInfoOther {
	if m != nil {
		return m.Other
	}
	return nil
}

// ProtocolVersion contains the protocol versions for the software running on
// the node.
type NodeInfo_ProtocolVersion struct {
	P2P   uint64 `protobuf:"varint,1,opt,name=p2p,proto3" json:"p2p,omitempty"`
	Block uint64 `protobuf:"varint,2,opt,name=block,proto3" json:"block,omitempty"`
	App   uint64 `protobuf:"varint,3,opt,name=app,proto3" json:"app,omitempty"`
}

func (m *NodeInfo_ProtocolVersion) Reset()         { *m = NodeInfo_ProtocolVersion{} }
func (m *NodeInfo_ProtocolVersion) String() string { return proto.CompactTextString(m) }
func (*NodeInfo_ProtocolVersion) ProtoMessage()    {}
func (*NodeInfo_ProtocolVersion) Descriptor() ([]byte, []int) {
	return fileDescriptor_c29a81d3e8b4adc4, []int{1, 0}
}
func (m *NodeInfo_ProtocolVersion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeInfo_ProtocolVersion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeInfo_ProtocolVersion.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeInfo_ProtocolVersion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeInfo_ProtocolVersion.Merge(m, src)
}
func (m *NodeInfo_ProtocolVersion) XXX_Size() int {
	return m.Size()
}
func (m *NodeInfo_ProtocolVersion) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeInfo_ProtocolVersion.DiscardUnknown(m)
}

var xxx_messageInfo_NodeInfo_ProtocolVersion proto.InternalMessageInfo

func (m *NodeInfo_ProtocolVersion) GetP2P() uint64 {
	if m != nil {
		return m.P2P
	}
	return 0
}

func (m *NodeInfo_ProtocolVersion) GetBlock() uint64 {
	if m != nil {
		return m.Block
	}
	return 0
}

func (m *NodeInfo_ProtocolVersion) GetApp() uint64 {
	if m != nil {
		return m.App
	}
	return 0
}

// NodeInfoOther contains miscellaneous application-specific data.
type NodeInfo_NodeInfoOther struct {
	TxIndex    string `protobuf:"bytes,1,opt,name=tx_index,json=txIndex,proto3" json:"tx_index,omitempty"`
	RpcAddress string `protobuf:"bytes,2,opt,name=rpc_address,json=rpcAddress,proto3" json:"rpc_address,omitempty"`
}

func (m *NodeInfo_NodeInfoOther) Reset()         { *m = NodeInfo_NodeInfoOther{} }
func (m *NodeInfo_NodeInfoOther) String() string { return proto.CompactTextString(m) }
func (*NodeInfo_NodeInfoOther) ProtoMessage()    {}
func (*NodeInfo_NodeInfoOther) Descriptor() ([]byte, []int) {
	return fileDescriptor_c29a81d3e8b4adc4, []int{1, 1}
}
func (m *NodeInfo_NodeInfoOther) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeInfo_NodeInfoOther) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeInfo_NodeInfoOther.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeInfo_NodeInfoOther) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeInfo_NodeInfoOther.Merge(m, src)
}
func (m *NodeInfo_NodeInfoOther) XXX_Size() int {
	return m.Size()
}
func (m *NodeInfo_NodeInfoOther) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeInfo_NodeInfoOther.DiscardUnknown(m)
}

var xxx_messageInfo_NodeInfo_NodeInfoOther proto.InternalMessageInfo

func (m *NodeInfo_NodeInfoOther) GetTxIndex() string {
	if m != nil {
		return m.TxIndex
	}
	return ""
}

func (m *NodeInfo_NodeInfoOther) GetRpcAddress() string {
	if m != nil {
		return m.RpcAddress
	}
	return ""
}

// SyncInfo contains information about the current syncing state of the node.
type SyncInfo struct {
	LatestBlockHash     []byte    `protobuf:"bytes,1,opt,name=latest_block_hash,json=latestBlockHash,proto3" json:"latest_block_hash,omitempty"`
	LatestAppHash       []byte    `protobuf:"bytes,2,opt,name=latest_app_hash,json=latestAppHash,proto3" json:"latest_app_hash,omitempty"`
	LatestBlockHeight   int64     `protobuf:"varint,3,opt,name=latest_block_height,json=latestBlockHeight,proto3" json:"latest_block_height,omitempty"`
	LatestBlockTime     time.Time `protobuf:"bytes,4,opt,name=latest_block_time,json=latestBlockTime,proto3,stdtime" json:"latest_block_time"`
	EarliestBlockHash   []byte    `protobuf:"bytes,5,opt,name=earliest_block_hash,json=earliestBlockHash,proto3" json:"earliest_block_hash,omitempty"`
	EarliestAppHash     []byte    `protobuf:"bytes,6,opt,name=earliest_app_hash,json=earliestAppHash,proto3" json:"earliest_app_hash,omitempty"`
	EarliestBlockHeight int64     `protobuf:"varint,7,opt,name=earliest_block_height,json=earliestBlockHeight,proto3" json:"earliest_block_height,omitempty"`
	EarliestBlockTime   time.Time `protobuf:"bytes,8,opt,name=earliest_block_time,json=earliestBlockTime,proto3,stdtime" json:"earliest_block_time"`
	CatchingUp          bool      `protobuf:"varint,9,opt,name=catching_up,json=catchingUp,proto3" json:"catching_up,omitempty"`
}

func (m *SyncInfo) Reset()         { *m = SyncInfo{} }
func (m *SyncInfo) String() string { return proto.CompactTextString(m) }
func (*SyncInfo) ProtoMessage()    {}
func (*SyncInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_c29a81d3e8b4adc4, []int{2}
}
func (m *SyncInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyncInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SyncInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SyncInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncInfo.Merge(m, src)
}
func (m *SyncInfo) XXX_Size() int {
	return m.Size()
}
func (m *SyncInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SyncInfo proto.InternalMessageInfo

func (m *SyncInfo) GetLatestBlockHash() []byte {
	if m != nil {
		return m.LatestBlockHash
	}
	return nil
}

func (m *SyncInfo) GetLatestAppHash() []byte {
	if m != nil {
		return m.LatestAppHash
	}
	return nil
}

func (m *SyncInfo) GetLatestBlockHeight() int64 {
	if m != nil {
		return m.LatestBlockHeight
	}
	return 0
}

func (m *SyncInfo) GetLatestBlockTime() time.Time {
	if m != nil {
		return m.LatestBlockTime
	}
	return time.Time{}
}

func (m *SyncInfo) GetEarliestBlockHash() []byte {
	if m != nil {
		return m.EarliestBlockHash
	}
	return nil
}

func (m *SyncInfo) GetEarliestAppHash() []byte {
	if m != nil {
		return m.EarliestAppHash
	}
	return nil
}

func (m *SyncInfo) GetEarliestBlockHeight() int64 {
	if m != nil {
		return m.EarliestBlockHeight
	}
	return 0
}

func (m *SyncInfo) GetEarliestBlockTime() time.Time {
	if m != nil {
		return m.EarliestBlockTime
	}
	return time.Time{}
}

func (m *SyncInfo) GetCatchingUp() bool {
	if m != nil {
		return m.CatchingUp
	}
	return false
}

// ValidatorInfo contains information about the node's validator.
type ValidatorInfo struct {
	Address     []byte `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	VotingPower int64  `protobuf:"varint,2,opt,name=voting_power,json=votingPower,proto3" json:"voting_power,omitempty"`
}

func (m *ValidatorInfo) Reset()         { *m = ValidatorInfo{} }
func (m *ValidatorInfo) String() string { return proto.CompactTextString(m) }
func (*ValidatorInfo) ProtoMessage()    {}
func (*ValidatorInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_c29a81d3e8b4adc4, []int{3}
}
func (m *ValidatorInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidatorInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorInfo.Merge(m, src)
}
func (m *ValidatorInfo) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorInfo proto.InternalMessageInfo

func (m *ValidatorInfo) GetAddress() []byte {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *ValidatorInfo) GetVotingPower() int64 {
	if m != nil {
		return m.VotingPower
	}
	return 0
}

// GetStatusResponse is what the gRPC endpoint GetStatus returns in response to
// a request.
// It contains information about the current state of the node.
type GetStatusResponse struct {
	NodeInfo      *NodeInfo      `protobuf:"bytes,1,opt,name=node_info,json=nodeInfo,proto3" json:"node_info,omitempty"`
	SyncInfo      *SyncInfo      `protobuf:"bytes,2,opt,name=sync_info,json=syncInfo,proto3" json:"sync_info,omitempty"`
	ValidatorInfo *ValidatorInfo `protobuf:"bytes,3,opt,name=validator_info,json=validatorInfo,proto3" json:"validator_info,omitempty"`
}

func (m *GetStatusResponse) Reset()         { *m = GetStatusResponse{} }
func (m *GetStatusResponse) String() string { return proto.CompactTextString(m) }
func (*GetStatusResponse) ProtoMessage()    {}
func (*GetStatusResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c29a81d3e8b4adc4, []int{4}
}
func (m *GetStatusResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetStatusResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetStatusResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetStatusResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetStatusResponse.Merge(m, src)
}
func (m *GetStatusResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetStatusResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetStatusResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetStatusResponse proto.InternalMessageInfo

func (m *GetStatusResponse) GetNodeInfo() *NodeInfo {
	if m != nil {
		return m.NodeInfo
	}
	return nil
}

func (m *GetStatusResponse) GetSyncInfo() *SyncInfo {
	if m != nil {
		return m.SyncInfo
	}
	return nil
}

func (m *GetStatusResponse) GetValidatorInfo() *ValidatorInfo {
	if m != nil {
		return m.ValidatorInfo
	}
	return nil
}

// GetHealthRequest is an empty message sent in a call to GetStatus.
// The GetHealth rpc call requires no parameter.
type GetHealthRequest struct {
}

func (m *GetHealthRequest) Reset()         { *m = GetHealthRequest{} }
func (m *GetHealthRequest) String() string { return proto.CompactTextString(m) }
func (*GetHealthRequest) ProtoMessage()    {}
func (*GetHealthRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c29a81d3e8b4adc4, []int{5}
}
func (m *GetHealthRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetHealthRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetHealthRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetHealthRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetHealthRequest.Merge(m, src)
}
func (m *GetHealthRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetHealthRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetHealthRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetHealthRequest proto.InternalMessageInfo

// GetHealthResponse is what the gRPC endpoint GetHealth returns in response to
// a request.
type GetHealthResponse struct {
}

func (m *GetHealthResponse) Reset()         { *m = GetHealthResponse{} }
func (m *GetHealthResponse) String() string { return proto.CompactTextString(m) }
func (*GetHealthResponse) ProtoMessage()    {}
func (*GetHealthResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c29a81d3e8b4adc4, []int{6}
}
func (m *GetHealthResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetHealthResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetHealthResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetHealthResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetHealthResponse.Merge(m, src)
}
func (m *GetHealthResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetHealthResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetHealthResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetHealthResponse proto.InternalMessageInfo

func init() {
	proto.RegisterType((*GetStatusRequest)(nil), "cometbft.services.node.v1.GetStatusRequest")
	proto.RegisterType((*NodeInfo)(nil), "cometbft.services.node.v1.NodeInfo")
	proto.RegisterType((*NodeInfo_ProtocolVersion)(nil), "cometbft.services.node.v1.NodeInfo.ProtocolVersion")
	proto.RegisterType((*NodeInfo_NodeInfoOther)(nil), "cometbft.services.node.v1.NodeInfo.NodeInfoOther")
	proto.RegisterType((*SyncInfo)(nil), "cometbft.services.node.v1.SyncInfo")
	proto.RegisterType((*ValidatorInfo)(nil), "cometbft.services.node.v1.ValidatorInfo")
	proto.RegisterType((*GetStatusResponse)(nil), "cometbft.services.node.v1.GetStatusResponse")
	proto.RegisterType((*GetHealthRequest)(nil), "cometbft.services.node.v1.GetHealthRequest")
	proto.RegisterType((*GetHealthResponse)(nil), "cometbft.services.node.v1.GetHealthResponse")
}

func init() {
	proto.RegisterFile("cometbft/services/node/v1/node.proto", fileDescriptor_c29a81d3e8b4adc4)
}

var fileDescriptor_c29a81d3e8b4adc4 = []byte{
	// 745 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x54, 0xcd, 0x4e, 0xe3, 0x48,
	0x10, 0x8e, 0xf3, 0x43, 0x9c, 0x0a, 0x21, 0xc4, 0xb0, 0x92, 0xc9, 0x21, 0xc9, 0x66, 0x57, 0xab,
	0x88, 0x83, 0x2d, 0xc2, 0x6d, 0x4f, 0xc0, 0x05, 0x10, 0xab, 0x05, 0x35, 0x2c, 0x87, 0x3d, 0xac,
	0xe5, 0xd8, 0x9d, 0xd8, 0xc2, 0x71, 0xf7, 0xba, 0x3b, 0x01, 0xde, 0x82, 0xc7, 0xe2, 0xc8, 0x71,
	0x4e, 0x33, 0x23, 0x38, 0x0c, 0x8f, 0x31, 0xea, 0xee, 0x74, 0x20, 0x19, 0x31, 0xc3, 0x9c, 0xd2,
	0xf5, 0x55, 0xd5, 0x97, 0xfa, 0xaa, 0xca, 0x05, 0xbf, 0x07, 0x64, 0x8c, 0xf9, 0x60, 0xc8, 0x5d,
	0x86, 0xb3, 0x69, 0x1c, 0x60, 0xe6, 0xa6, 0x24, 0xc4, 0xee, 0x74, 0x47, 0xfe, 0x3a, 0x34, 0x23,
	0x9c, 0x58, 0x5b, 0x3a, 0xca, 0xd1, 0x51, 0x8e, 0xf4, 0x4e, 0x77, 0x9a, 0x9b, 0x23, 0x32, 0x22,
	0x32, 0xca, 0x15, 0x2f, 0x95, 0xd0, 0x6c, 0x8f, 0x08, 0x19, 0x25, 0xd8, 0x95, 0xd6, 0x60, 0x32,
	0x74, 0x79, 0x3c, 0xc6, 0x8c, 0xfb, 0x63, 0xaa, 0x02, 0xba, 0x16, 0xac, 0x1f, 0x62, 0x7e, 0xce,
	0x7d, 0x3e, 0x61, 0x08, 0xff, 0x3f, 0xc1, 0x8c, 0x77, 0x9f, 0x0b, 0x60, 0xfe, 0x4d, 0x42, 0x7c,
	0x9c, 0x0e, 0x89, 0xf5, 0x1f, 0xac, 0xcb, 0xc8, 0x80, 0x24, 0xde, 0x14, 0x67, 0x2c, 0x26, 0xa9,
	0x6d, 0x74, 0x8c, 0x5e, 0xb5, 0xbf, 0xeb, 0xbc, 0x59, 0x8d, 0xa3, 0xd3, 0x9d, 0xb3, 0x59, 0xee,
	0xa5, 0x4a, 0x45, 0x75, 0xba, 0x08, 0x58, 0x6b, 0x90, 0x8f, 0x43, 0x3b, 0xdf, 0x31, 0x7a, 0x15,
	0x94, 0x8f, 0x43, 0xab, 0x0d, 0xd5, 0x24, 0x66, 0x1c, 0xa7, 0x9e, 0x1f, 0x86, 0x99, 0x5d, 0x90,
	0x0e, 0x50, 0xd0, 0x7e, 0x18, 0x66, 0x96, 0x0d, 0xe5, 0x14, 0xf3, 0x6b, 0x92, 0x5d, 0xd9, 0x45,
	0xe9, 0xd4, 0xa6, 0xf0, 0xe8, 0x0a, 0x4b, 0xca, 0x33, 0x33, 0xad, 0x26, 0x98, 0x41, 0xe4, 0xa7,
	0x29, 0x4e, 0x98, 0xbd, 0xd2, 0x31, 0x7a, 0xab, 0x68, 0x6e, 0x8b, 0xac, 0x31, 0x49, 0xe3, 0x2b,
	0x9c, 0xd9, 0x65, 0x95, 0x35, 0x33, 0xad, 0x43, 0x28, 0x11, 0x1e, 0xe1, 0xcc, 0x36, 0xa5, 0xde,
	0x9d, 0xf7, 0xe8, 0xd5, 0x8f, 0x53, 0x91, 0x88, 0x54, 0x7e, 0xf3, 0x04, 0xea, 0x4b, 0x7d, 0xb0,
	0xd6, 0xa1, 0x40, 0xfb, 0x54, 0x76, 0xb2, 0x88, 0xc4, 0xd3, 0xda, 0x84, 0xd2, 0x20, 0x21, 0xc1,
	0x95, 0xec, 0x45, 0x11, 0x29, 0x43, 0xc4, 0xf9, 0x94, 0xca, 0x36, 0x14, 0x91, 0x78, 0x36, 0x4f,
	0xa0, 0xb6, 0xf0, 0x27, 0xd6, 0x16, 0x98, 0xfc, 0xc6, 0x8b, 0xd3, 0x10, 0xdf, 0x48, 0xbe, 0x0a,
	0x2a, 0xf3, 0x9b, 0x63, 0x61, 0x8a, 0x66, 0x66, 0x34, 0x90, 0x9d, 0xc4, 0x8c, 0xcd, 0xba, 0x0c,
	0x19, 0x0d, 0xf6, 0x15, 0xd2, 0xfd, 0x52, 0x00, 0xf3, 0xfc, 0x36, 0x0d, 0xe4, 0xa8, 0xb7, 0xa1,
	0x91, 0xf8, 0x1c, 0x33, 0xee, 0xc9, 0xff, 0xf6, 0x22, 0x9f, 0x45, 0x92, 0x71, 0x15, 0xd5, 0x95,
	0xe3, 0x40, 0xe0, 0x47, 0x3e, 0x8b, 0xac, 0x3f, 0x60, 0x06, 0x79, 0x3e, 0xa5, 0x2a, 0x32, 0x2f,
	0x23, 0x6b, 0x0a, 0xde, 0xa7, 0x54, 0xc6, 0x39, 0xb0, 0xb1, 0xc8, 0x89, 0xe3, 0x51, 0xc4, 0xa5,
	0x9e, 0x02, 0x6a, 0xbc, 0x66, 0x95, 0x0e, 0xeb, 0x6c, 0xa9, 0x06, 0xb1, 0xaf, 0x72, 0xce, 0xd5,
	0x7e, 0xd3, 0x51, 0xcb, 0xec, 0xe8, 0x65, 0x76, 0x2e, 0xf4, 0x32, 0x1f, 0x98, 0xf7, 0x1f, 0xdb,
	0xb9, 0xbb, 0x4f, 0x6d, 0x63, 0xa1, 0x52, 0xe1, 0x17, 0x15, 0x60, 0x3f, 0x4b, 0xe2, 0x25, 0x5d,
	0x25, 0x59, 0x6d, 0x43, 0xbb, 0x5e, 0x94, 0x6d, 0xc3, 0x1c, 0x7c, 0xd1, 0xa6, 0x96, 0xa6, 0xae,
	0x1d, 0x5a, 0x5d, 0x1f, 0x7e, 0x59, 0xe6, 0x56, 0xfa, 0xca, 0x52, 0xdf, 0xc6, 0x22, 0xbb, 0x52,
	0x78, 0xf1, 0x4d, 0x3d, 0x52, 0xa3, 0xf9, 0x13, 0x1a, 0x17, 0xab, 0x96, 0x2a, 0xdb, 0x50, 0x0d,
	0x7c, 0x1e, 0x44, 0x71, 0x3a, 0xf2, 0x26, 0xd4, 0xae, 0x74, 0x8c, 0x9e, 0x89, 0x40, 0x43, 0xff,
	0xd0, 0xee, 0x5f, 0x50, 0xbb, 0xf4, 0x93, 0x38, 0xf4, 0x39, 0xc9, 0xe4, 0xb4, 0x6d, 0x28, 0xeb,
	0xbd, 0x50, 0x33, 0xd6, 0xa6, 0xf5, 0x2b, 0xac, 0x4e, 0x09, 0x17, 0x4c, 0x94, 0x5c, 0xe3, 0x4c,
	0x0e, 0xb6, 0x80, 0xaa, 0x0a, 0x3b, 0x13, 0x50, 0xf7, 0xd9, 0x80, 0xc6, 0xab, 0xbb, 0xc1, 0x28,
	0x49, 0x19, 0xb6, 0xf6, 0xa0, 0x22, 0x3e, 0x08, 0x2f, 0x4e, 0x87, 0x64, 0x76, 0x24, 0x7e, 0x7b,
	0xc7, 0x47, 0x83, 0xcc, 0x54, 0x5f, 0x9b, 0x3d, 0xa8, 0xb0, 0xdb, 0x34, 0x50, 0x0c, 0xf9, 0x1f,
	0x32, 0xe8, 0xd5, 0x45, 0x26, 0xd3, 0x4b, 0x7c, 0x0a, 0x6b, 0x53, 0xad, 0x53, 0xd1, 0x14, 0x24,
	0x4d, 0xef, 0x3b, 0x34, 0x0b, 0x8d, 0x41, 0xb5, 0xe9, 0x6b, 0x73, 0x76, 0x21, 0x8f, 0xb0, 0x9f,
	0xf0, 0x48, 0x5f, 0xc8, 0x0d, 0xa9, 0x5e, 0x63, 0x4a, 0xfd, 0xc1, 0xc5, 0xfd, 0x63, 0xcb, 0x78,
	0x78, 0x6c, 0x19, 0x9f, 0x1f, 0x5b, 0xc6, 0xdd, 0x53, 0x2b, 0xf7, 0xf0, 0xd4, 0xca, 0x7d, 0x78,
	0x6a, 0xe5, 0xfe, 0xfd, 0x73, 0x14, 0xf3, 0x68, 0x32, 0x10, 0x15, 0xb8, 0xf3, 0x3b, 0x3f, 0x7f,
	0xf8, 0x34, 0x76, 0xdf, 0xbc, 0xfe, 0x83, 0x15, 0xb9, 0x09, 0xbb, 0x5f, 0x03, 0x00, 0x00, 0xff,
	0xff, 0xed, 0x9b, 0x6f, 0x9b, 0x21, 0x06, 0x00, 0x00,
}

func (m *GetStatusRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetStatusRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetStatusRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *NodeInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Other != nil {
		{
			size, err := m.Other.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.Moniker) > 0 {
		i -= len(m.Moniker)
		copy(dAtA[i:], m.Moniker)
		i = encodeVarintNode(dAtA, i, uint64(len(m.Moniker)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Channels) > 0 {
		i -= len(m.Channels)
		copy(dAtA[i:], m.Channels)
		i = encodeVarintNode(dAtA, i, uint64(len(m.Channels)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintNode(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Network) > 0 {
		i -= len(m.Network)
		copy(dAtA[i:], m.Network)
		i = encodeVarintNode(dAtA, i, uint64(len(m.Network)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ListenAddr) > 0 {
		i -= len(m.ListenAddr)
		copy(dAtA[i:], m.ListenAddr)
		i = encodeVarintNode(dAtA, i, uint64(len(m.ListenAddr)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintNode(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x12
	}
	if m.ProtocolVersion != nil {
		{
			size, err := m.ProtocolVersion.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NodeInfo_ProtocolVersion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeInfo_ProtocolVersion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeInfo_ProtocolVersion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.App != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.App))
		i--
		dAtA[i] = 0x18
	}
	if m.Block != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.Block))
		i--
		dAtA[i] = 0x10
	}
	if m.P2P != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.P2P))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NodeInfo_NodeInfoOther) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeInfo_NodeInfoOther) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeInfo_NodeInfoOther) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RpcAddress) > 0 {
		i -= len(m.RpcAddress)
		copy(dAtA[i:], m.RpcAddress)
		i = encodeVarintNode(dAtA, i, uint64(len(m.RpcAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TxIndex) > 0 {
		i -= len(m.TxIndex)
		copy(dAtA[i:], m.TxIndex)
		i = encodeVarintNode(dAtA, i, uint64(len(m.TxIndex)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SyncInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SyncInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CatchingUp {
		i--
		if m.CatchingUp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	n3, err3 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.EarliestBlockTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.EarliestBlockTime):])
	if err3 != nil {
		return 0, err3
	}
	i -= n3
	i = encodeVarintNode(dAtA, i, uint64(n3))
	i--
	dAtA[i] = 0x42
	if m.EarliestBlockHeight != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.EarliestBlockHeight))
		i--
		dAtA[i] = 0x38
	}
	if len(m.EarliestAppHash) > 0 {
		i -= len(m.EarliestAppHash)
		copy(dAtA[i:], m.EarliestAppHash)
		i = encodeVarintNode(dAtA, i, uint64(len(m.EarliestAppHash)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.EarliestBlockHash) > 0 {
		i -= len(m.EarliestBlockHash)
		copy(dAtA[i:], m.EarliestBlockHash)
		i = encodeVarintNode(dAtA, i, uint64(len(m.EarliestBlockHash)))
		i--
		dAtA[i] = 0x2a
	}
	n4, err4 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.LatestBlockTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.LatestBlockTime):])
	if err4 != nil {
		return 0, err4
	}
	i -= n4
	i = encodeVarintNode(dAtA, i, uint64(n4))
	i--
	dAtA[i] = 0x22
	if m.LatestBlockHeight != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.LatestBlockHeight))
		i--
		dAtA[i] = 0x18
	}
	if len(m.LatestAppHash) > 0 {
		i -= len(m.LatestAppHash)
		copy(dAtA[i:], m.LatestAppHash)
		i = encodeVarintNode(dAtA, i, uint64(len(m.LatestAppHash)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.LatestBlockHash) > 0 {
		i -= len(m.LatestBlockHash)
		copy(dAtA[i:], m.LatestBlockHash)
		i = encodeVarintNode(dAtA, i, uint64(len(m.LatestBlockHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ValidatorInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidatorInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.VotingPower != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.VotingPower))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintNode(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetStatusResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetStatusResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetStatusResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ValidatorInfo != nil {
		{
			size, err := m.ValidatorInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.SyncInfo != nil {
		{
			size, err := m.SyncInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.NodeInfo != nil {
		{
			size, err := m.NodeInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetHealthRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetHealthRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetHealthRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *GetHealthResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetHealthResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetHealthResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintNode(dAtA []byte, offset int, v uint64) int {
	offset -= sovNode(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *GetStatusRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *NodeInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProtocolVersion != nil {
		l = m.ProtocolVersion.Size()
		n += 1 + l + sovNode(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	l = len(m.ListenAddr)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	l = len(m.Network)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	l = len(m.Channels)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	l = len(m.Moniker)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	if m.Other != nil {
		l = m.Other.Size()
		n += 1 + l + sovNode(uint64(l))
	}
	return n
}

func (m *NodeInfo_ProtocolVersion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.P2P != 0 {
		n += 1 + sovNode(uint64(m.P2P))
	}
	if m.Block != 0 {
		n += 1 + sovNode(uint64(m.Block))
	}
	if m.App != 0 {
		n += 1 + sovNode(uint64(m.App))
	}
	return n
}

func (m *NodeInfo_NodeInfoOther) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TxIndex)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	l = len(m.RpcAddress)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	return n
}

func (m *SyncInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.LatestBlockHash)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	l = len(m.LatestAppHash)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	if m.LatestBlockHeight != 0 {
		n += 1 + sovNode(uint64(m.LatestBlockHeight))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.LatestBlockTime)
	n += 1 + l + sovNode(uint64(l))
	l = len(m.EarliestBlockHash)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	l = len(m.EarliestAppHash)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	if m.EarliestBlockHeight != 0 {
		n += 1 + sovNode(uint64(m.EarliestBlockHeight))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.EarliestBlockTime)
	n += 1 + l + sovNode(uint64(l))
	if m.CatchingUp {
		n += 2
	}
	return n
}

func (m *ValidatorInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	if m.VotingPower != 0 {
		n += 1 + sovNode(uint64(m.VotingPower))
	}
	return n
}

func (m *GetStatusResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeInfo != nil {
		l = m.NodeInfo.Size()
		n += 1 + l + sovNode(uint64(l))
	}
	if m.SyncInfo != nil {
		l = m.SyncInfo.Size()
		n += 1 + l + sovNode(uint64(l))
	}
	if m.ValidatorInfo != nil {
		l = m.ValidatorInfo.Size()
		n += 1 + l + sovNode(uint64(l))
	}
	return n
}

func (m *GetHealthRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *GetHealthResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovNode(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozNode(x uint64) (n int) {
	return sovNode(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GetStatusRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetStatusRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetStatusRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolVersion", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProtocolVersion == nil {
				m.ProtocolVersion = &NodeInfo_ProtocolVersion{}
			}
			if err := m.ProtocolVersion.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListenAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ListenAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Network = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channels", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channels = append(m.Channels[:0], dAtA[iNdEx:postIndex]...)
			if m.Channels == nil {
				m.Channels = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Moniker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Moniker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Other", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Other == nil {
				m.Other = &NodeInfo_NodeInfoOther{}
			}
			if err := m.Other.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeInfo_ProtocolVersion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProtocolVersion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProtocolVersion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field P2P", wireType)
			}
			m.P2P = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.P2P |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			m.Block = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Block |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field App", wireType)
			}
			m.App = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.App |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeInfo_NodeInfoOther) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeInfoOther: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeInfoOther: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxIndex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxIndex = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RpcAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RpcAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestBlockHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LatestBlockHash = append(m.LatestBlockHash[:0], dAtA[iNdEx:postIndex]...)
			if m.LatestBlockHash == nil {
				m.LatestBlockHash = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestAppHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LatestAppHash = append(m.LatestAppHash[:0], dAtA[iNdEx:postIndex]...)
			if m.LatestAppHash == nil {
				m.LatestAppHash = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestBlockHeight", wireType)
			}
			m.LatestBlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LatestBlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestBlockTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.LatestBlockTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EarliestBlockHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EarliestBlockHash = append(m.EarliestBlockHash[:0], dAtA[iNdEx:postIndex]...)
			if m.EarliestBlockHash == nil {
				m.EarliestBlockHash = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EarliestAppHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EarliestAppHash = append(m.EarliestAppHash[:0], dAtA[iNdEx:postIndex]...)
			if m.EarliestAppHash == nil {
				m.EarliestAppHash = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EarliestBlockHeight", wireType)
			}
			m.EarliestBlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EarliestBlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EarliestBlockTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.EarliestBlockTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CatchingUp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CatchingUp = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidatorInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatorInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatorInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = append(m.Address[:0], dAtA[iNdEx:postIndex]...)
			if m.Address == nil {
				m.Address = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VotingPower", wireType)
			}
			m.VotingPower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VotingPower |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetStatusResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetStatusResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetStatusResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeInfo == nil {
				m.NodeInfo = &NodeInfo{}
			}
			if err := m.NodeInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyncInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SyncInfo == nil {
				m.SyncInfo = &SyncInfo{}
			}
			if err := m.SyncInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ValidatorInfo == nil {
				m.ValidatorInfo = &ValidatorInfo{}
			}
			if err := m.ValidatorInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetHealthRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetHealthRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetHealthRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetHealthResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetHealthResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetHealthResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipNode(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowNode
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNode
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNode
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthNode
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupNode
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthNode
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthNode        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowNode          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupNode = fmt.Errorf("proto: unexpected end of group")
)
